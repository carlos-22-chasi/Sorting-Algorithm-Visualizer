import React from 'react';
import {getMergeSortAnimations} from '../SortingAlgorithms/MergeSort.js';
import {getQuickSortAnimations} from '../SortingAlgorithms/QuickSort.js';
import {getBubbleSortAnimations} from '../SortingAlgorithms/BubbleSort.js';
import {getInsertionSortAnimations} from '../SortingAlgorithms/InsertionSort.js';
import {getSelectionSortAnimations} from '../SortingAlgorithms/SelectionSort.js';
import {getCombSortAnimations} from '../SortingAlgorithms/CombSort.js';
import {getRadixSortAnimations} from '../SortingAlgorithms/RadixSort.js';
import {getBucketSortAnimations} from '../SortingAlgorithms/BucketSort.js';
import {getHeapSortAnimations} from '../SortingAlgorithms/HeapSort.js';



import './SortingVisualizer.css';

// Change this value for the speed of the animations.
const ANIMATION_SPEED_MS = 100;

// Change this value for the number of bars (value) in the array.
const NUMBER_OF_ARRAY_BARS = 25;

// This is the main color of the array bars.
const PRIMARY_COLOR = '#079BFF';

// This is the color of array bars that are being compared throughout the animations.
const SECONDARY_COLOR = 'red';

// This is the color of array bars that are going to be swapped throughout the animations.
const THIRD_COLOR = '#40D531'

export default class SortingVisualizer extends React.Component {
  constructor(props) {
    super(props);

    this.state = {
      array: [],
      isAnimating: false
    };
  }

  componentDidMount() {
    this.resetArray();
  }

  resetArray() {
    const array = [];
    for (let i = 0; i < NUMBER_OF_ARRAY_BARS; i++) {
      array.push(randomIntFromInterval(5, 500));
    }
    // const array = [200,600,500,300,650,400,100, 601, 599, 580, 150, 100, 580];
    // const array = [20, 80, 50, 30, 90, 10];
    this.setState({array: array});
  }
  //updates the header content 
  changeHeader(newHeader){
    const nameHeader = document.getElementById('name-holder');
    nameHeader.textContent = newHeader;

  }
  //updates the description content 
  changeDescription(newDescription){
    const description = document.getElementById('description-holder');
    description.textContent = newDescription;
  }

  mergeSort() {
    this.changeHeader('Merge Sort');
    this.changeDescription('Merge sort is a divide-and-conquer algorithm that efficiently sorts an array by breaking it down into smaller subarrays, sorting those, and then merging them back together. The process begins by recursively dividing the array into halves until each subarray contains only one element, which is inherently sorted. Then, the algorithm merges these small, sorted subarrays in pairs by comparing their elements and placing them in order, creating larger sorted subarrays. This merging process continues until the entire array is reassembled into a single sorted array. Merge sort is particularly efficient because it consistently operates in O(n log n) time complexity, making it one of the most reliable sorting algorithms for handling large datasets.');

    // Get the list of animations generated by the merge sort algorithm
    const animations = getMergeSortAnimations(this.state.array);
    this.animate(animations);
  }
  quickSort() {
    this.changeHeader('Quick Sort');
    this.changeDescription("Quicksort is a highly efficient, divide-and-conquer sorting algorithm that works by selecting a 'pivot' element from an array and then partitioning the other elements into two subarrays according to whether they are less than or greater than the pivot. The pivot is placed in its correct position in the sorted array. This process is then recursively applied to the subarrays, resulting in the entire array being sorted. The partitioning step, where elements are rearranged around the pivot, is key to quicksort's efficiency. Although its average-case time complexity is O(n log n), quicksort can be faster than other O(n log n) algorithms like merge sort due to its in-place sorting and reduced overhead.");

    // Get the list of animations generated by the quick sort algorithm
    const animations = getQuickSortAnimations(this.state.array);
    this.animate(animations);
  }

  bubbleSort() {
    this.changeHeader('Bubble Sort');
    this.changeDescription("Bubble sort is a simple comparison-based sorting algorithm that repeatedly steps through a list, compares adjacent elements, and swaps them if they are in the wrong order. This process is repeated for each pair of adjacent elements, starting from the beginning of the list, until the entire list is sorted. The largest element 'bubbles' up to the end of the list during each pass, and the algorithm continues to iterate through the list, each time reducing the range of elements to be sorted by one. This continues until no more swaps are needed, indicating that the list is fully sorted. Although easy to understand and implement, bubble sort is inefficient for large datasets, with a time complexity of O(n²) in the worst and average cases, making it impractical for sorting large lists.");

    // Get the list of animations generated by the merge sort algorithm
    const animations = getBubbleSortAnimations(this.state.array);
    this.animate(animations);
  }

  insertionSort() {
    this.changeHeader('Insertion Sort');
    this.changeDescription('Insertion sort is a straightforward, comparison-based sorting algorithm that builds the final sorted array one element at a time. It works by dividing the list into a "sorted" and an "unsorted" section. Initially, the sorted section contains just the first element, and the unsorted section contains the rest. The algorithm then takes each element from the unsorted section and places it in the correct position within the sorted section. This is done by shifting elements that are greater than the current element to the right, making space to insert the current element in its proper position. This process is repeated until all elements are sorted. Insertion sort is efficient for small or nearly sorted datasets, with a time complexity of O(n²) in the worst case, but it can be faster than more complex algorithms for small or mostly sorted data.');

    // Get the list of animations generated by the insertion sort algorithm
    const animations = getInsertionSortAnimations(this.state.array);
    this.animate(animations);
  }

  selectionSort(){
    this.changeHeader('Selection Sort');
    this.changeDescription('Selection sort is a simple comparison-based sorting algorithm that divides the array into two parts: a sorted section and an unsorted section. Initially, the sorted section is empty, and the unsorted section contains all the elements. The algorithm repeatedly selects the smallest element from the unsorted section and swaps it with the first element of the unsorted section, effectively moving it to the sorted section. This process continues, moving the boundary between the sorted and unsorted sections one element to the right each time, until the entire array is sorted. Selection sort has a time complexity of O(n²).');

    // Get the list of animations generated by the selection sort algorithm
    const animations = getSelectionSortAnimations(this.state.array);
    this.animate(animations);
  }

  combSort(){
    this.changeHeader('Comb Sort');
    this.changeDescription('Comb sort is an improvement over the bubble sort algorithm that aims to eliminate small values at the end of the list that slow down sorting. The key idea in comb sort is to compare and swap elements that are far apart initially, gradually reducing the gap between elements as the algorithm progresses. Starting with a gap value, typically initialized as the array length divided by a shrink factor (commonly 1.3), the algorithm compares elements at this gap distance and swaps them if they are in the wrong order. After each pass, the gap is reduced, usually by dividing it by the shrink factor, until it eventually becomes 1, at which point the algorithm functions like a bubble sort. This method significantly reduces the number of swaps needed, making comb sort more efficient than bubble sort, with an average time complexity closer to O(n log n)');

    // Get the list of animations generated by the comb sort algorithm
    const animations = getCombSortAnimations(this.state.array);
    this.animate(animations);
  }

  radixSort(){
    this.changeHeader('Radix Sort');
    this.changeDescription('Radix Sort efficiently sorts an array of integers by leveraging the Counting Sort algorithm on each digit place, starting from the least significant digit. It first identifies the maximum number in the array to determine the number of digit places to sort. For each digit place, the countSort algorithm is used to tally occurrences of each digit and compute their final positions in the sorted array. This ensures that elements are sorted correctly according to their digit values, while maintaining the order established by previous digit places. The sorted array from each digit place is then used for subsequent passes. It has a time complexity of O(d * (n + b)), where d is the number of digits, n is the number of elements, and b is the base of the number system being used. In practical implementations, radix sort is often faster than other comparison-based sorting algorithms, such as quicksort or merge sort, for large datasets, especially when the keys have many digits. However, its time complexity grows linearly with the number of digits, and so it is not as efficient for small datasets.');

     // Get the list of animations generated by the radix sort algorithm
     const animations = getRadixSortAnimations(this.state.array);
     this.animate(animations);
  }

  bucketSort(){
    this.changeHeader('Bucket Sort');
    this.changeDescription('Bucket Sort is an efficient sorting algorithm that distributes elements of an array into several buckets based on their values. The process begins by creating a number of empty buckets, typically the length of the input size. Each element from the input array is then placed into the appropriate bucket based on a calculated index or value range. Once all elements are distributed into buckets, each bucket is sorted individually, often using another sorting algorithm such as Insertion Sort. After sorting the individual buckets, the algorithm concatenates the contents of all buckets to form the final sorted array. This approach is particularly effective when the input values are uniformly distributed across a known range, as it can significantly reduce the time complexity compared to traditional comparison-based sorting methods.  Bucket Sort has an average case time complexity of O(n) and a worst case complexity of O(n2).');

    // Get the list of animations generated by the bucket sort algorithm
    const animations = getBucketSortAnimations(this.state.array);
    this.animate(animations);
  }

  heapSort(){
    this.changeHeader('Heap Sort');
    this.changeDescription('Heap Sort is a comparison-based sorting algorithm that leverages the properties of a binary heap data structure to efficiently sort elements. The process begins by building a max heap from the input array, which transforms the array into a binary heap where each parent node is greater than or equal to its child nodes. This is achieved through a series of heapify operations that ensure the heap property is maintained. Once the max heap is built, the algorithm repeatedly extracts the maximum element from the heap (the root of the heap) and places it at the end of the array, reducing the heap size by one each time. After each extraction, the heap is restructured to maintain the heap property. This extraction and heapify process continues until all elements are sorted. Heap Sort is advantageous due to its O(n log n) time complexity and does not require additional space beyond the input array, making it an efficient in-place sorting algorithm.');

    // Get the list of animations generated by the heap sort algorithm
    const animations = getHeapSortAnimations(this.state.array);
    this.animate(animations);
  }

  animate(animations) {
    this.setState({ isAnimating: true }, () => {
    // Loop through each animation step
    for (let i = 0; i < animations.length; i++) {
      const arrayBars = document.getElementsByClassName('array-bar');
      const action = animations[i][0];

      if (action === "compare" || action === "revert") {
        const [barOneIdx, barTwoIdx] = [animations[i][1], animations[i][2]];
        // If the action is "compare" then change color to secondary color, else change to primary color
        const color = action === "compare" ? SECONDARY_COLOR : PRIMARY_COLOR;
        // Change the color of the two bars being compared after a certain amount of time
        setTimeout(() => {
          const barOneStyle = arrayBars[barOneIdx].style;
          const barTwoStyle = arrayBars[barTwoIdx].style;

          barOneStyle.backgroundColor = color;
          barTwoStyle.backgroundColor = color;
        }, i * ANIMATION_SPEED_MS);
      } 
      // If the action is swap, then we change the height of the bars to give a swapping effect
      else if (action === "swap") {
        const [barOneIdx, newHeightOne, barTwoIdx, newHeightTwo] = [animations[i][1], animations[i][2], animations[i][3], animations[i][4]];
        
        const barOneStyle = arrayBars[barOneIdx].style;
        const barTwoStyle = arrayBars[barTwoIdx].style;

        const barOneValue = arrayBars[barOneIdx];
        const barTwoValue = arrayBars[barTwoIdx];
        // First, turn the bars green
        setTimeout(() => {
          barOneStyle.backgroundColor = THIRD_COLOR;
          barTwoStyle.backgroundColor = THIRD_COLOR;
        }, i * ANIMATION_SPEED_MS);
        // Then turn bars back to primary color
        setTimeout(() => {
          barOneStyle.backgroundColor = PRIMARY_COLOR;
          barTwoStyle.backgroundColor = PRIMARY_COLOR;
        }, i * ANIMATION_SPEED_MS + ANIMATION_SPEED_MS/3);
         // Finally, swap the heights of the two bars after a certain amount of time
        setTimeout(() => {
          barOneStyle.height = `${newHeightOne}px`;
          barTwoStyle.height = `${newHeightTwo}px`;

          barOneValue.textContent = newHeightOne;
          barTwoValue.textContent = newHeightTwo;

        }, i * ANIMATION_SPEED_MS + (ANIMATION_SPEED_MS*2)/3);
      }
      else if (action === "overwrite"){
        const [barOneIdx, newHeightOne] = [animations[i][1], animations[i][2]];
        setTimeout(() => {
          const barOneStyle = arrayBars[barOneIdx].style;
          barOneStyle.height = `${newHeightOne}px`;

          const barOneValue = arrayBars[barOneIdx];
          barOneValue.textContent = newHeightOne;

        }, i * ANIMATION_SPEED_MS);
      }
      else if (action === "check" || action === "uncheck") {
        const barOneIdx = animations[i][1];
        // If the action is "compare" then change color to secondary color, else change to primary color
        const color = action === "check" ? SECONDARY_COLOR : PRIMARY_COLOR;
        // Change the color of the two bars being compared after a certain amount of time
        setTimeout(() => {
          const barOneStyle = arrayBars[barOneIdx].style;
          barOneStyle.backgroundColor = color;
        }, i * ANIMATION_SPEED_MS);
      } 
    } 
    setTimeout(() => {
      this.setState({ isAnimating: false });
      const sortedArray = [...this.state.array].sort((a, b) => a - b);
      this.setState({array: sortedArray});
    },  animations.length * ANIMATION_SPEED_MS);
    });

  }

  render() {
    const {array} = this.state;

    return (
      <div className='main'>
        <div id = 'name-holder'>Sorting Algorithm Visualizer</div>
        <div className="array-container">
          {array.map((value, idx) => (
            <div className="array-bar" key={idx}
              style={{
                backgroundColor: PRIMARY_COLOR,
                height: `${value}px`,
              }}>
                {value}
              </div>
          ))}
        </div>
        <div className='button-container'>
          <button onClick={() => window.location.reload()}>Generate New Array</button>
          <button onClick={() => this.mergeSort()} disabled = {this.state.isAnimating}>Merge Sort</button>
          <button onClick={() => this.quickSort()} disabled = {this.state.isAnimating}>Quick Sort</button>
          <button onClick={() => this.bubbleSort()} disabled = {this.state.isAnimating}>Bubble Sort</button>
          <button onClick={() => this.insertionSort()} disabled = {this.state.isAnimating}>Insertion Sort</button>
          <button onClick={() => this.selectionSort()} disabled = {this.state.isAnimating}>Selection Sort</button>
          <button onClick={() => this.combSort()} disabled = {this.state.isAnimating}>Comb Sort</button>
          <button onClick={() => this.radixSort()} disabled = {this.state.isAnimating}>Radix Sort</button>
          <button onClick={() => this.bucketSort()} disabled = {this.state.isAnimating}>Bucket Sort</button>
          <button onClick={() => this.heapSort()} disabled = {this.state.isAnimating}>Heap Sort</button>
          <p>Bar colors:
            <span id = "blue"> Blue:</span> Bars are not being currently compared
            <span id = "red"> Red:</span> Bars are currently being compared
            <span id = "green"> Green:</span> Bars have been compared and need to be swapped
          </p>
        </div>
        <div id='description-holder'>
          <p>Sorting Algorithms Descriptions</p>
        </div>
      </div>
    );
  }
}

// From https://stackoverflow.com/questions/4959975/generate-random-number-between-two-numbers-in-javascript
function randomIntFromInterval(min, max) {
  // min and max included
  return Math.floor(Math.random() * (max - min + 1) + min);
}
